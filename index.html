<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Grand Chandelier | Offline Visualization</title>
    <style>
      :root {
        --bg: #06080d;
        --panel: #0e1422;
        --panel-2: #121b2e;
        --line: #293247;
        --text: #e8eef9;
        --muted: #9fb0ca;
        --accent: #38bdf8;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
      }

      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        color: var(--text);
        background:
          radial-gradient(circle at 14% 18%, #1a2942 0%, transparent 34%),
          radial-gradient(circle at 85% 8%, #132033 0%, transparent 29%),
          var(--bg);
      }

      .page {
        width: 100%;
        height: 100%;
        padding: 16px;
        display: grid;
        gap: 14px;
        grid-template-columns: 340px 1fr;
      }

      .card {
        border: 1px solid var(--line);
        border-radius: 16px;
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        box-shadow: 0 14px 44px rgba(0, 0, 0, 0.38);
      }

      .controls {
        padding: 16px;
        overflow: auto;
      }

      h1 {
        margin: 0;
        font-size: 1.12rem;
        letter-spacing: 0.01em;
      }

      .subtitle {
        margin: 8px 0 0;
        color: var(--muted);
        font-size: 0.9rem;
        line-height: 1.45;
      }

      .group {
        margin-top: 16px;
        border: 1px solid #2a354d;
        border-radius: 12px;
        padding: 12px;
        background: rgba(8, 12, 22, 0.5);
      }

      .group-title {
        font-size: 0.76rem;
        color: #a6b8d3;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        margin-bottom: 10px;
        font-weight: 700;
      }

      .row {
        display: grid;
        gap: 6px;
        margin-bottom: 10px;
      }

      .row:last-child {
        margin-bottom: 0;
      }

      label {
        font-size: 0.77rem;
        color: #adc0dc;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-weight: 700;
      }

      input[type="number"] {
        width: 100%;
        border: 1px solid #385070;
        border-radius: 9px;
        padding: 8px 10px;
        background: #0b1321;
        color: #eaf2ff;
        font-size: 0.92rem;
      }

      input[type="range"] {
        width: 100%;
        accent-color: var(--accent);
      }

      .value {
        font-size: 0.86rem;
        color: #73cbff;
        font-weight: 600;
      }

      .stats {
        margin-top: 14px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .stat {
        border: 1px solid #2d3951;
        border-radius: 10px;
        background: rgba(10, 15, 26, 0.65);
        padding: 9px;
      }

      .stat-k {
        color: #8fa5c6;
        font-size: 0.73rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      .stat-v {
        margin-top: 4px;
        font-size: 0.96rem;
        font-weight: 700;
      }

      .hint {
        margin-top: 14px;
        color: #90a5c4;
        font-size: 0.77rem;
        line-height: 1.45;
      }

      .viewer {
        position: relative;
        overflow: hidden;
      }

      .viewer-tabs {
        position: absolute;
        left: 12px;
        top: 12px;
        z-index: 5;
        display: flex;
        gap: 6px;
      }

      .viewer-arrows {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 5;
        display: grid;
        grid-template-columns: 40px 40px 40px;
        grid-template-rows: 40px 40px 40px;
        gap: 6px;
      }

      .viewer-arrows.hidden {
        display: none;
      }

      .arrow-btn {
        border: 1px solid #2f3a50;
        border-radius: 9px;
        background: rgba(6, 11, 20, 0.85);
        color: #d3e3fb;
        font-size: 1.05rem;
        font-weight: 700;
        cursor: pointer;
        user-select: none;
        touch-action: none;
      }

      .arrow-btn:active {
        background: rgba(38, 66, 109, 0.95);
        border-color: #5a88cd;
      }

      .tab-btn {
        border: 1px solid #2f3a50;
        border-radius: 9px;
        background: rgba(6, 11, 20, 0.8);
        color: #9fb1cb;
        font-size: 0.76rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-weight: 700;
        padding: 6px 10px;
        cursor: pointer;
      }

      .tab-btn.active {
        color: #e8f2ff;
        border-color: #4a7cc0;
        background: rgba(29, 53, 92, 0.9);
      }

      #viewport {
        width: 100%;
        height: 100%;
        display: block;
        cursor: grab;
      }

      #viewport.grabbing {
        cursor: grabbing;
      }

      #topViewport {
        width: 100%;
        height: 100%;
        display: none;
        cursor: crosshair;
      }

      #tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(4, 8, 16, 0.92);
        border: 1px solid #31415c;
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 0.78rem;
        color: #d9e6f8;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.4);
        transform: translate(12px, -12px);
        display: none;
        max-width: 210px;
      }

      #status {
        position: absolute;
        left: 12px;
        top: 54px;
        border: 1px solid #2f3a50;
        border-radius: 10px;
        background: rgba(6, 11, 20, 0.8);
        padding: 6px 10px;
        color: #c4d4eb;
        font-size: 0.77rem;
      }

      #error {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        text-align: center;
        background: rgba(5, 9, 15, 0.96);
        color: #ffd8d8;
        padding: 20px;
        line-height: 1.5;
      }

      @media (max-width: 1060px) {
        .page {
          grid-template-columns: 1fr;
        }

        .controls {
          max-height: 42vh;
        }

        .viewer {
          min-height: 56vh;
        }
      }
    </style>
  </head>
  <body>
    <main class="page">
      <aside class="card controls">
        <h1>Грандлюстра Сбер</h1>
        <p class="subtitle">
          Автономная визуализация без CDN: 1x1м сетка, контур и рисунок плотности по референсу/файлам модели. Длина нитей зависит от паттерна.
        </p>

        <section class="group">
          <div class="row">
            <label for="totalThreads">Общее количество нитей</label>
            <input id="totalThreads" type="number" min="1000" max="200000" step="100" value="44800" />
            <div id="totalThreadsValue" class="value">44 800 нитей</div>
          </div>

          <div class="row">
            <label>Источник паттерна</label>
            <div id="patternSourceValue" class="value">Загрузка профиля из chandelier.dwg...</div>
          </div>
        </section>

        <section class="stats" id="stats"></section>

        <p class="hint">
          Наведение: выделяется квадрат 1x1м и показывается число нитей и средняя длина в зоне. Общее число нитей задается вводом цифры. Управление: ЛКМ вращение, ПКМ панорама, колесо масштаб.
        </p>

      </aside>

      <section class="card viewer">
        <div class="viewer-tabs">
          <button id="tab3d" class="tab-btn active" type="button">3D</button>
          <button id="tab2d" class="tab-btn" type="button">2D вид сверху</button>
        </div>
        <div id="viewerArrows" class="viewer-arrows" aria-label="Поворот модели">
          <span></span>
          <button id="rotUp" class="arrow-btn" type="button" aria-label="Повернуть вверх">↑</button>
          <span></span>
          <button id="rotLeft" class="arrow-btn" type="button" aria-label="Повернуть влево">←</button>
          <span></span>
          <button id="rotRight" class="arrow-btn" type="button" aria-label="Повернуть вправо">→</button>
          <span></span>
          <button id="rotDown" class="arrow-btn" type="button" aria-label="Повернуть вниз">↓</button>
          <span></span>
        </div>
        <canvas id="viewport"></canvas>
        <canvas id="topViewport"></canvas>
        <div id="status">Инициализация...</div>
        <div id="tooltip"></div>
        <div id="error"></div>
      </section>
    </main>

    <script src="./dwg_profile.js"></script>
    <script>
      (() => {
        "use strict";

        const statusEl = document.getElementById("status");
        const viewport = document.getElementById("viewport");
        const topViewport = document.getElementById("topViewport");
        const tooltip = document.getElementById("tooltip");
        const errorEl = document.getElementById("error");
        const statsEl = document.getElementById("stats");
        const densityMap = document.getElementById("densityMap");
        const dctx = densityMap ? densityMap.getContext("2d") : null;
        const tab3dBtn = document.getElementById("tab3d");
        const tab2dBtn = document.getElementById("tab2d");
        const viewerArrows = document.getElementById("viewerArrows");
        const rotUpBtn = document.getElementById("rotUp");
        const rotDownBtn = document.getElementById("rotDown");
        const rotLeftBtn = document.getElementById("rotLeft");
        const rotRightBtn = document.getElementById("rotRight");

        const totalThreadsInput = document.getElementById("totalThreads");
        const totalThreadsValue = document.getElementById("totalThreadsValue");
        const patternSourceValue = document.getElementById("patternSourceValue");

        const ctx = viewport.getContext("2d", { alpha: false, desynchronized: true });
        const topCtx = topViewport.getContext("2d", { alpha: false, desynchronized: true });
        if (!ctx) {
          errorEl.style.display = "flex";
          errorEl.textContent = "Canvas 2D не поддерживается в этом окружении.";
          return;
        }
        if (!topCtx) {
          errorEl.style.display = "flex";
          errorEl.textContent = "Canvas 2D (top view) не поддерживается в этом окружении.";
          return;
        }

        const GRID_W = 80;
        const GRID_H = 40;
        const CELL = 1;
        const MIN_DENSITY = 4;
        const MAX_DENSITY = 30;
        const DEFAULT_MIN_HEIGHT = 2;
        const DEFAULT_MAX_HEIGHT = 10.8;
        const DEFAULT_LENGTH_PATTERN_INFLUENCE = 0.92;
        const DEFAULT_NOISE_FREQUENCY = 0.095;
        const SEED = 1307;
        const DEFAULT_TOTAL_THREADS = 44800;
        const DWG_PROFILE = window.__DWG_PROFILE || null;

        const SHAPE_POLYGON = [
          [0.02, 0.2],
          [0.13, 0.2],
          [0.13, 0.09],
          [0.17, 0.09],
          [0.17, 0.2],
          [0.43, 0.2],
          [0.43, 0.09],
          [0.78, 0.09],
          [0.78, 0.14],
          [0.92, 0.14],
          [0.97, 0.18],
          [0.98, 0.33],
          [0.98, 0.55],
          [0.95, 0.71],
          [0.91, 0.86],
          [0.84, 0.93],
          [0.68, 0.93],
          [0.53, 0.9],
          [0.35, 0.87],
          [0.2, 0.84],
          [0.11, 0.82],
          [0.07, 0.74],
          [0.04, 0.58],
          [0.03, 0.4]
        ];

        const SHAPE_HOLES = [
          [0.18, 0.09, 0.25, 0.21],
          [0.28, 0.09, 0.43, 0.2]
        ];

        const state = {
          width: 1,
          height: 1,
          dpr: Math.min(window.devicePixelRatio || 1, 2),
          fov: 44 * (Math.PI / 180),
          focal: 1,

          yaw: 0.72,
          pitch: 0.62,
          distance: 88,
          target: { x: 0, y: -3.1, z: 0 },

          camPos: { x: 0, y: 0, z: 0 },
          basisRight: { x: 1, y: 0, z: 0 },
          basisUp: { x: 0, y: 1, z: 0 },
          basisForward: { x: 0, y: 0, z: 1 },

          rods: {
            x: new Float32Array(0),
            z: new Float32Array(0),
            h: new Float32Array(0),
            color: [],
            count: 0
          },

          panelDensity: new Int16Array(GRID_W * GRID_H),
          panelRaw: new Float32Array(GRID_W * GRID_H),
          panelLength: new Float32Array(GRID_W * GRID_H),
          activePanels: 0,
          minDensity: 0,
          maxDensity: 0,
          meanDensity: 0,
          minLength: DEFAULT_MIN_HEIGHT,
          maxLength: DEFAULT_MAX_HEIGHT,
          meanLength: 0,
          referenceMap: null,
          dxfProfile: DWG_PROFILE,

          hover: null,
          activeTab: "3d",
          mouse: { x: 0, y: 0 },
          dragging: false,
          dragButton: 0,
          lastMouseX: 0,
          lastMouseY: 0,

          needsRender: true,
          pendingRebuild: null
        };

        function v3(x, y, z) {
          return { x, y, z };
        }

        function add(a, b) {
          return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
        }

        function sub(a, b) {
          return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
        }

        function mul(a, s) {
          return { x: a.x * s, y: a.y * s, z: a.z * s };
        }

        function dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z;
        }

        function cross(a, b) {
          return {
            x: a.y * b.z - a.z * b.y,
            y: a.z * b.x - a.x * b.z,
            z: a.x * b.y - a.y * b.x
          };
        }

        function length(a) {
          return Math.sqrt(dot(a, a));
        }

        function normalize(a) {
          const len = length(a);
          if (len < 1e-8) return { x: 0, y: 0, z: 0 };
          return { x: a.x / len, y: a.y / len, z: a.z / len };
        }

        function clamp(v, lo, hi) {
          return Math.max(lo, Math.min(hi, v));
        }

        function lerp(a, b, t) {
          return a + (b - a) * t;
        }

        function smoothstep(edge0, edge1, x) {
          const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
          return t * t * (3 - 2 * t);
        }

        function mulberry32(seed) {
          let t = seed >>> 0;
          return () => {
            t += 0x6d2b79f5;
            let r = Math.imul(t ^ (t >>> 15), 1 | t);
            r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
            return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
          };
        }

        function hashFloat(a, b, c, seed) {
          let x = (a * 374761393 + b * 668265263 + c * 2147483647 + seed * 1274126177) >>> 0;
          x ^= x >>> 13;
          x = Math.imul(x, 1274126177) >>> 0;
          x ^= x >>> 16;
          return (x & 0xffffff) / 0xffffff;
        }

        function buildPermutation(seed) {
          const rnd = mulberry32(seed);
          const p = new Uint8Array(512);
          const perm = new Uint8Array(256);
          for (let i = 0; i < 256; i++) perm[i] = i;
          for (let i = 255; i > 0; i--) {
            const j = Math.floor(rnd() * (i + 1));
            const t = perm[i];
            perm[i] = perm[j];
            perm[j] = t;
          }
          for (let i = 0; i < 512; i++) p[i] = perm[i & 255];
          return p;
        }

        function grad(hash, x, y) {
          const h = hash & 7;
          const u = h < 4 ? x : y;
          const v = h < 4 ? y : x;
          return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
        }

        function fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10);
        }

        function perlin2D(x, y, p) {
          const X = Math.floor(x) & 255;
          const Y = Math.floor(y) & 255;
          const xf = x - Math.floor(x);
          const yf = y - Math.floor(y);
          const u = fade(xf);
          const v = fade(yf);

          const aa = p[p[X] + Y];
          const ab = p[p[X] + Y + 1];
          const ba = p[p[X + 1] + Y];
          const bb = p[p[X + 1] + Y + 1];

          const x1 = lerp(grad(aa, xf, yf), grad(ba, xf - 1, yf), u);
          const x2 = lerp(grad(ab, xf, yf - 1), grad(bb, xf - 1, yf - 1), u);
          return lerp(x1, x2, v) * 0.5;
        }

        function fbm(x, y, p, octaves, lacunarity, gain) {
          let amp = 0.5;
          let freq = 1;
          let sum = 0;
          let norm = 0;
          for (let i = 0; i < octaves; i++) {
            sum += amp * perlin2D(x * freq, y * freq, p);
            norm += amp;
            amp *= gain;
            freq *= lacunarity;
          }
          return sum / norm;
        }

        function densityColorCss(t) {
          const c1 = [36, 99, 255];
          const c2 = [34, 197, 94];
          const c3 = [250, 204, 21];
          const c4 = [239, 68, 68];

          let a;
          let b;
          let tt;
          if (t <= 0.33) {
            a = c1;
            b = c2;
            tt = t / 0.33;
          } else if (t <= 0.66) {
            a = c2;
            b = c3;
            tt = (t - 0.33) / 0.33;
          } else {
            a = c3;
            b = c4;
            tt = (t - 0.66) / 0.34;
          }

          const r = Math.round(lerp(a[0], b[0], tt));
          const g = Math.round(lerp(a[1], b[1], tt));
          const bch = Math.round(lerp(a[2], b[2], tt));
          return "rgb(" + r + "," + g + "," + bch + ")";
        }

        function integralSum(integral, w, h, x0, y0, x1, y1) {
          const xx0 = clamp(x0, 0, w);
          const yy0 = clamp(y0, 0, h);
          const xx1 = clamp(x1, 0, w);
          const yy1 = clamp(y1, 0, h);
          const row = w + 1;
          const a = integral[yy0 * row + xx0];
          const b = integral[yy0 * row + xx1];
          const c = integral[yy1 * row + xx0];
          const d = integral[yy1 * row + xx1];
          return d - b - c + a;
        }

        function preprocessReferenceImage(img) {
          const canvas = document.createElement("canvas");
          canvas.width = img.naturalWidth || img.width;
          canvas.height = img.naturalHeight || img.height;
          const c2 = canvas.getContext("2d", { willReadFrequently: true });
          c2.drawImage(img, 0, 0);

          const w = canvas.width;
          const h = canvas.height;
          const pixels = c2.getImageData(0, 0, w, h).data;

          let borderLumaSum = 0;
          let borderCount = 0;
          for (let x = 0; x < w; x++) {
            const t = (0 * w + x) * 4;
            const b = ((h - 1) * w + x) * 4;
            borderLumaSum += (pixels[t] + pixels[t + 1] + pixels[t + 2]) / 765;
            borderLumaSum += (pixels[b] + pixels[b + 1] + pixels[b + 2]) / 765;
            borderCount += 2;
          }
          for (let y = 1; y < h - 1; y++) {
            const l = (y * w + 0) * 4;
            const r = (y * w + (w - 1)) * 4;
            borderLumaSum += (pixels[l] + pixels[l + 1] + pixels[l + 2]) / 765;
            borderLumaSum += (pixels[r] + pixels[r + 1] + pixels[r + 2]) / 765;
            borderCount += 2;
          }
          const backgroundLuma = borderCount ? borderLumaSum / borderCount : 0.86;
          const normDenom = Math.max(0.08, backgroundLuma - 0.08);

          const ink = new Float32Array(w * h);
          let minX = w;
          let minY = h;
          let maxX = 0;
          let maxY = 0;

          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const idx = y * w + x;
              const p = idx * 4;
              const luma = (pixels[p] + pixels[p + 1] + pixels[p + 2]) / 765;
              const rawInk = clamp((backgroundLuma - luma) / normDenom, 0, 1);
              ink[idx] = rawInk;

              if (rawInk > 0.18) {
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
              }
            }
          }

          if (minX >= maxX || minY >= maxY) {
            minX = 0;
            minY = 0;
            maxX = w - 1;
            maxY = h - 1;
          }

          const padX = Math.floor((maxX - minX + 1) * 0.02);
          const padY = Math.floor((maxY - minY + 1) * 0.02);
          minX = clamp(minX - padX, 0, w - 1);
          minY = clamp(minY - padY, 0, h - 1);
          maxX = clamp(maxX + padX, 0, w - 1);
          maxY = clamp(maxY + padY, 0, h - 1);

          const integral = new Float32Array((w + 1) * (h + 1));
          for (let y = 1; y <= h; y++) {
            let rowSum = 0;
            for (let x = 1; x <= w; x++) {
              rowSum += ink[(y - 1) * w + (x - 1)];
              integral[y * (w + 1) + x] = integral[(y - 1) * (w + 1) + x] + rowSum;
            }
          }

          return {
            w,
            h,
            ink,
            integral,
            minX,
            minY,
            maxX,
            maxY
          };
        }

        function loadReferenceMap(src) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              try {
                resolve(preprocessReferenceImage(img));
              } catch (err) {
                reject(err);
              }
            };
            img.onerror = () => reject(new Error("Не удалось загрузить карту паттерна"));
            img.src = src;
          });
        }

        function sampleReference(referenceMap, u, v, radiusPx) {
          const bboxW = referenceMap.maxX - referenceMap.minX + 1;
          const bboxH = referenceMap.maxY - referenceMap.minY + 1;

          const x = referenceMap.minX + clamp(u, 0, 1) * (bboxW - 1);
          const y = referenceMap.minY + clamp(v, 0, 1) * (bboxH - 1);

          const x0 = Math.floor(x - radiusPx);
          const y0 = Math.floor(y - radiusPx);
          const x1 = Math.floor(x + radiusPx) + 1;
          const y1 = Math.floor(y + radiusPx) + 1;

          const sum = integralSum(referenceMap.integral, referenceMap.w, referenceMap.h, x0, y0, x1, y1);
          const area = Math.max(1, (x1 - x0) * (y1 - y0));
          return sum / area;
        }

        function pointInPolygon(x, y, polygon) {
          let inside = false;
          for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i][0];
            const yi = polygon[i][1];
            const xj = polygon[j][0];
            const yj = polygon[j][1];
            const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi + 1e-12) + xi;
            if (intersect) inside = !inside;
          }
          return inside;
        }

        function insideReferenceShape(x, z) {
          const u = (x + GRID_W * 0.5) / GRID_W;
          const v = (z + GRID_H * 0.5) / GRID_H;
          if (u < 0 || u > 1 || v < 0 || v > 1) return false;
          if (!pointInPolygon(u, v, SHAPE_POLYGON)) return false;

          for (let i = 0; i < SHAPE_HOLES.length; i++) {
            const hole = SHAPE_HOLES[i];
            if (u >= hole[0] && u <= hole[2] && v >= hole[1] && v <= hole[3]) {
              return false;
            }
          }
          return true;
        }

        function updateCameraBasis() {
          state.pitch = clamp(state.pitch, 0.14, 1.2);
          state.distance = clamp(state.distance, 35, 180);

          const cp = Math.cos(state.pitch);
          const sp = Math.sin(state.pitch);
          const cy = Math.cos(state.yaw);
          const sy = Math.sin(state.yaw);

          state.camPos.x = state.target.x + state.distance * cp * sy;
          state.camPos.y = state.target.y + state.distance * sp;
          state.camPos.z = state.target.z + state.distance * cp * cy;

          state.basisForward = normalize(sub(state.target, state.camPos));
          const worldUp = v3(0, 1, 0);
          state.basisRight = normalize(cross(state.basisForward, worldUp));
          state.basisUp = normalize(cross(state.basisRight, state.basisForward));
        }

        function projectPoint(x, y, z) {
          const v = v3(x - state.camPos.x, y - state.camPos.y, z - state.camPos.z);
          const cx = dot(v, state.basisRight);
          const cy = dot(v, state.basisUp);
          const cz = dot(v, state.basisForward);
          if (cz <= 0.08) return null;

          const sx = state.width * 0.5 + (cx * state.focal) / cz;
          const sy = state.height * 0.5 - (cy * state.focal) / cz;
          return { sx, sy, cz };
        }

        function screenRayToGround(mouseX, mouseY) {
          const nx = (mouseX - state.width * 0.5) / state.focal;
          const ny = -(mouseY - state.height * 0.5) / state.focal;

          const dir = normalize(
            add(
              add(mul(state.basisRight, nx), mul(state.basisUp, ny)),
              state.basisForward
            )
          );

          const dy = dir.y;
          if (Math.abs(dy) < 1e-6) return null;

          const t = (0 - state.camPos.y) / dy;
          if (t <= 0) return null;

          return add(state.camPos, mul(dir, t));
        }

        function rebuildSimulation() {
          const freq = DEFAULT_NOISE_FREQUENCY;
          const parsedTarget = Number(totalThreadsInput.value);
          const minLength = DEFAULT_MIN_HEIGHT;
          const maxLength = DEFAULT_MAX_HEIGHT;
          const lengthPatternInfluence = DEFAULT_LENGTH_PATTERN_INFLUENCE;

          const targetTotal = clamp(
            Number.isFinite(parsedTarget) ? Math.round(parsedTarget) : DEFAULT_TOTAL_THREADS,
            1000,
            200000
          );

          totalThreadsInput.value = String(targetTotal);
          totalThreadsValue.textContent = targetTotal.toLocaleString("ru-RU") + " нитей";
          state.minLength = minLength;
          state.maxLength = maxLength;

          statusEl.textContent = "Пересчет карты плотности...";

          const useReferencePattern = false;
          const dxf = state.dxfProfile;
          const useDxfProfile =
            !!dxf &&
            dxf.grid_w === GRID_W &&
            dxf.grid_h === GRID_H &&
            Array.isArray(dxf.cells) &&
            dxf.cells.length === GRID_W * GRID_H;

          if (useDxfProfile && useReferencePattern) {
            patternSourceValue.textContent = "DWG профиль (форма/плотность/высота)";
          } else if (useDxfProfile) {
            patternSourceValue.textContent = "DWG профиль (форма/плотность/высота)";
          } else if (useReferencePattern) {
            patternSourceValue.textContent = "DWG профиль не загружен";
          } else {
            patternSourceValue.textContent = "Фолбэк-паттерн (без DWG профиля)";
          }

          const pDensity = buildPermutation(SEED + 11);
          const pWarpA = buildPermutation(SEED + 23);
          const pWarpB = buildPermutation(SEED + 37);
          const pHeight = buildPermutation(SEED + 53);

          state.panelDensity = new Int16Array(GRID_W * GRID_H);
          state.panelRaw = new Float32Array(GRID_W * GRID_H);
          state.panelLength = new Float32Array(GRID_W * GRID_H);
          state.panelDensity.fill(-1);

          const cells = [];
          let rawDensitySum = 0;
          const dxfZMin = useDxfProfile ? dxf.bounds.z_min : 0;
          const dxfZMax = useDxfProfile ? dxf.bounds.z_max : 1;
          const dxfZSpan = Math.max(1e-9, dxfZMax - dxfZMin);
          const dxfCountMax = useDxfProfile ? Math.max(1, dxf.count_max || 1) : 1;
          let dxfLenLo = 0;
          let dxfLenHi = 1;
          if (useDxfProfile) {
            const rawLens = [];
            for (let idx = 0; idx < dxf.cells.length; idx++) {
              const c = dxf.cells[idx];
              if (!c || c.count <= 0) continue;
              const occ = c.count / dxfCountMax;
              if (occ < 0.012) continue;
              const tRaw = clamp((c.mean_z - dxfZMin) / dxfZSpan, 0, 1);
              rawLens.push(tRaw);
            }
            if (rawLens.length > 8) {
              rawLens.sort((a, b) => a - b);
              const loIdx = Math.floor((rawLens.length - 1) * 0.05);
              const hiIdx = Math.floor((rawLens.length - 1) * 0.95);
              dxfLenLo = rawLens[loIdx];
              dxfLenHi = rawLens[hiIdx];
              if (dxfLenHi - dxfLenLo < 1e-4) {
                dxfLenLo = rawLens[0];
                dxfLenHi = rawLens[rawLens.length - 1];
              }
            }
          }

          for (let j = 0; j < GRID_H; j++) {
            for (let i = 0; i < GRID_W; i++) {
              const x = (i - GRID_W * 0.5 + 0.5) * CELL;
              const z = (j - GRID_H * 0.5 + 0.5) * CELL;
              let rawDensity = 0;
              let densityN = 0;
              let lengthN = 0;

              if (useDxfProfile) {
                const dCell = dxf.cells[j * GRID_W + i];
                const occ = dCell.count / dxfCountMax;
                if (occ < 0.012) continue;

                const dxfDensityN = smoothstep(0.01, 0.68, Math.pow(occ, 0.85));
                const dxfLengthRaw = clamp((dCell.mean_z - dxfZMin) / dxfZSpan, 0, 1);
                const dxfLengthN = clamp((dxfLengthRaw - dxfLenLo) / Math.max(1e-6, dxfLenHi - dxfLenLo), 0, 1);

                if (useReferencePattern) {
                  const scale = clamp(freq / 0.095, 0.55, 1.85);
                  let u = (i + 0.5) / GRID_W;
                  let v = (j + 0.5) / GRID_H;
                  u = (u - 0.5) * scale + 0.5;
                  v = (v - 0.5) * scale + 0.5;

                  const occRef = sampleReference(state.referenceMap, u, v, 5);
                  if (occRef < 0.009) continue;
                  const inkFine = sampleReference(state.referenceMap, u, v, 2);
                  const inkCoarse = sampleReference(state.referenceMap, u, v, 6);
                  const refDensityN = smoothstep(0.01, 0.30, inkFine * 0.74 + inkCoarse * 0.26);

                  densityN = clamp(dxfDensityN * 0.65 + refDensityN * 0.35, 0, 1);
                  lengthN = clamp(dxfLengthN * 0.78 + refDensityN * 0.22, 0, 1);
                } else {
                  densityN = dxfDensityN;
                  lengthN = dxfLengthN;
                }

                rawDensity = lerp(MIN_DENSITY, MAX_DENSITY, densityN);
              } else if (useReferencePattern) {
                const scale = clamp(freq / 0.095, 0.55, 1.85);
                let u = (i + 0.5) / GRID_W;
                let v = (j + 0.5) / GRID_H;
                u = (u - 0.5) * scale + 0.5;
                v = (v - 0.5) * scale + 0.5;

                const occupancy = sampleReference(state.referenceMap, u, v, 5);
                if (occupancy < 0.014) continue;

                const inkFine = sampleReference(state.referenceMap, u, v, 2);
                const inkCoarse = sampleReference(state.referenceMap, u, v, 6);
                densityN = smoothstep(0.01, 0.30, inkFine * 0.74 + inkCoarse * 0.26);
                lengthN = densityN;
                rawDensity = lerp(MIN_DENSITY, MAX_DENSITY, densityN);
              } else {
                if (!insideReferenceShape(x, z)) continue;

                const ux = x * freq;
                const uz = z * freq;

                const warpX = fbm(ux * 0.7, uz * 0.7, pWarpA, 4, 2, 0.5) * 2.1;
                const warpZ = fbm(ux * 0.7 + 18.7, uz * 0.7 - 9.3, pWarpB, 4, 2, 0.5) * 2.1;
                const swirl = fbm(ux + warpX, uz + warpZ, pDensity, 6, 2, 0.5) * 0.5 + 0.5;
                const detail = fbm((ux - 13.2) * 1.6, (uz + 7.9) * 1.6, pWarpB, 3, 2, 0.56) * 0.5 + 0.5;

                const rrX = (x + 8.0) * freq * 1.15;
                const rrZ = (z + 0.5) * freq * 1.15;
                const rings = Math.sin(Math.sqrt(rrX * rrX + rrZ * rrZ) * 7.0 + detail * 4.8) * 0.5 + 0.5;

                const field = swirl * 0.58 + detail * 0.2 + rings * 0.22;
                densityN = smoothstep(0.1, 0.92, field);
                lengthN = densityN;
                rawDensity = lerp(MIN_DENSITY, MAX_DENSITY, densityN);
              }

              cells.push({ i, j, x, z, rawDensity, densityN, lengthN, density: 0 });
              rawDensitySum += rawDensity;
            }
          }

          if (!cells.length || rawDensitySum <= 0) {
            state.rods = { x: new Float32Array(0), z: new Float32Array(0), h: new Float32Array(0), color: [], count: 0 };
            state.activePanels = 0;
            state.minDensity = 0;
            state.maxDensity = 0;
            state.meanDensity = 0;
            statsEl.innerHTML = "";
            statusEl.textContent = "Нет активных панелей";
            state.needsRender = true;
            return;
          }

          const allocationScale = targetTotal / rawDensitySum;
          const fractions = new Array(cells.length);
          let totalRods = 0;

          for (let idx = 0; idx < cells.length; idx++) {
            const exact = cells[idx].rawDensity * allocationScale;
            const base = Math.floor(exact);
            cells[idx].density = Math.max(0, base);
            fractions[idx] = exact - base;
            totalRods += cells[idx].density;
          }

          let remaining = targetTotal - totalRods;
          if (remaining > 0) {
            const order = fractions.map((_, idx) => idx).sort((a, b) => fractions[b] - fractions[a]);
            const lim = Math.min(remaining, order.length);
            for (let t = 0; t < lim; t++) {
              cells[order[t]].density += 1;
            }
            remaining -= lim;
          }

          if (remaining > 0) {
            let ring = 0;
            while (remaining > 0) {
              cells[ring % cells.length].density += 1;
              ring++;
              remaining--;
            }
          }

          let minD = Infinity;
          let maxD = -Infinity;
          let sumD = 0;
          let sumPattern = 0;
          totalRods = 0;
          for (let idx = 0; idx < cells.length; idx++) {
            const density = cells[idx].density;
            totalRods += density;
            minD = Math.min(minD, density);
            maxD = Math.max(maxD, density);
            sumD += density;
            sumPattern += cells[idx].densityN;
            state.panelDensity[cells[idx].j * GRID_W + cells[idx].i] = density;
            state.panelRaw[cells[idx].j * GRID_W + cells[idx].i] = cells[idx].densityN;
            state.panelLength[cells[idx].j * GRID_W + cells[idx].i] = cells[idx].lengthN;
          }

          const rodX = new Float32Array(totalRods);
          const rodZ = new Float32Array(totalRods);
          const rodH = new Float32Array(totalRods);
          const rodColor = new Array(totalRods);

          let ptr = 0;
          let sumHeight = 0;
          for (let c = 0; c < cells.length; c++) {
            const cell = cells[c];
            const t = (cell.density - minD) / Math.max(1, maxD - minD);
            const col = densityColorCss(t);

            for (let k = 0; k < cell.density; k++) {
              const jx = hashFloat(cell.i, cell.j, k * 11 + 3, SEED) - 0.5;
              const jz = hashFloat(cell.i, cell.j, k * 19 + 7, SEED + 17) - 0.5;
              const px = cell.x + jx * 0.92;
              const pz = cell.z + jz * 0.92;

              const hN = fbm(px * 0.12, pz * 0.12, pHeight, 5, 2, 0.54) * 0.5 + 0.5;
              const localVariation = hashFloat(cell.i, cell.j, k * 29 + 13, SEED + 99) - 0.5;
              const lengthN = clamp(
                (1 - lengthPatternInfluence) * hN + lengthPatternInfluence * cell.lengthN + localVariation * 0.06,
                0,
                1
              );
              const h = lerp(minLength, maxLength, Math.pow(lengthN, 0.9));

              rodX[ptr] = px;
              rodZ[ptr] = pz;
              rodH[ptr] = h;
              rodColor[ptr] = col;
              sumHeight += h;
              ptr++;
            }
          }

          state.rods = {
            x: rodX,
            z: rodZ,
            h: rodH,
            color: rodColor,
            count: totalRods
          };

          state.activePanels = cells.length;
          state.minDensity = minD;
          state.maxDensity = maxD;
          state.meanDensity = cells.length ? sumD / cells.length : 0;
          state.meanLength = totalRods ? sumHeight / totalRods : 0;
          statsEl.innerHTML = [
            ["Количество нитей", "44 800"],
            ["Общая длина нитей", "133 072 м"],
            ["Общая площадь люстры", "2 800 кв.м"],
            ["Рабочая мощность люстры", "240 кВт"],
            ["Адресов управления", "903 480"],
            ["RGBW светильников", "180 696"]
          ]
            .map(
              (item) =>
                '<div class="stat"><div class="stat-k">' +
                item[0] +
                '</div><div class="stat-v">' +
                item[1] +
                "</div></div>"
            )
            .join("");

          statusEl.textContent =
            "Готово: " +
            totalRods.toLocaleString() +
            " нитей | длины " +
            minLength.toFixed(1) +
            "-" +
            maxLength.toFixed(1) +
            "м | " +
            (useDxfProfile ? "DWG mode" : "fallback mode");
          state.needsRender = true;
        }

        function drawFloorFrame() {
          const corners = [
            projectPoint(-GRID_W * 0.5, 0, -GRID_H * 0.5),
            projectPoint(GRID_W * 0.5, 0, -GRID_H * 0.5),
            projectPoint(GRID_W * 0.5, 0, GRID_H * 0.5),
            projectPoint(-GRID_W * 0.5, 0, GRID_H * 0.5)
          ];

          if (!corners[0] || !corners[1] || !corners[2] || !corners[3]) return;

          ctx.beginPath();
          ctx.moveTo(corners[0].sx, corners[0].sy);
          ctx.lineTo(corners[1].sx, corners[1].sy);
          ctx.lineTo(corners[2].sx, corners[2].sy);
          ctx.lineTo(corners[3].sx, corners[3].sy);
          ctx.closePath();
          ctx.fillStyle = "rgba(14, 22, 40, 0.58)";
          ctx.fill();
          ctx.strokeStyle = "rgba(74, 98, 134, 0.46)";
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        function drawHoveredPanel() {
          if (!state.hover) return;
          const i = state.hover.i;
          const j = state.hover.j;
          const x0 = i - GRID_W * 0.5;
          const x1 = x0 + 1;
          const z0 = j - GRID_H * 0.5;
          const z1 = z0 + 1;

          const p0 = projectPoint(x0, 0.02, z0);
          const p1 = projectPoint(x1, 0.02, z0);
          const p2 = projectPoint(x1, 0.02, z1);
          const p3 = projectPoint(x0, 0.02, z1);
          if (!p0 || !p1 || !p2 || !p3) return;

          ctx.beginPath();
          ctx.moveTo(p0.sx, p0.sy);
          ctx.lineTo(p1.sx, p1.sy);
          ctx.lineTo(p2.sx, p2.sy);
          ctx.lineTo(p3.sx, p3.sy);
          ctx.closePath();
          ctx.fillStyle = "rgba(244, 63, 94, 0.42)";
          ctx.fill();
          ctx.strokeStyle = "rgba(255, 183, 198, 0.98)";
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo((p0.sx + p2.sx) * 0.5, (p0.sy + p2.sy) * 0.5 - 6);
          ctx.lineTo((p0.sx + p2.sx) * 0.5, (p0.sy + p2.sy) * 0.5 + 6);
          ctx.moveTo((p0.sx + p2.sx) * 0.5 - 6, (p0.sy + p2.sy) * 0.5);
          ctx.lineTo((p0.sx + p2.sx) * 0.5 + 6, (p0.sy + p2.sy) * 0.5);
          ctx.strokeStyle = "rgba(255, 235, 238, 0.95)";
          ctx.lineWidth = 1.2;
          ctx.stroke();
        }

        function drawRods() {
          const rods = state.rods;
          ctx.lineWidth = 1;
          ctx.globalAlpha = 0.97;

          let prevColor = "";
          for (let i = 0; i < rods.count; i++) {
            const x = rods.x[i];
            const z = rods.z[i];
            const h = rods.h[i];

            const top = projectPoint(x, 0, z);
            if (!top) continue;
            const bottom = projectPoint(x, -h, z);
            if (!bottom) continue;

            if (
              (top.sx < -50 && bottom.sx < -50) ||
              (top.sx > state.width + 50 && bottom.sx > state.width + 50) ||
              (top.sy < -50 && bottom.sy < -50) ||
              (top.sy > state.height + 50 && bottom.sy > state.height + 50)
            ) {
              continue;
            }

            const c = rods.color[i];
            if (c !== prevColor) {
              ctx.strokeStyle = c;
              prevColor = c;
            }

            ctx.beginPath();
            ctx.moveTo(top.sx, top.sy);
            ctx.lineTo(bottom.sx, bottom.sy);
            ctx.stroke();
          }

          ctx.globalAlpha = 1;
        }

        function drawDensityMap() {
          if (!dctx) return;
          const w = densityMap.width;
          const h = densityMap.height;
          dctx.clearRect(0, 0, w, h);
          dctx.fillStyle = "#0a1020";
          dctx.fillRect(0, 0, w, h);

          const cw = w / GRID_W;
          const ch = h / GRID_H;
          for (let j = 0; j < GRID_H; j++) {
            for (let i = 0; i < GRID_W; i++) {
              const idx = j * GRID_W + i;
              const density = state.panelDensity[idx];
              if (density < 0) continue;
              const t = (density - state.minDensity) / Math.max(1, state.maxDensity - state.minDensity);
              dctx.fillStyle = densityColorCss(t);
              dctx.fillRect(i * cw, j * ch, Math.ceil(cw + 0.35), Math.ceil(ch + 0.35));
            }
          }

          if (state.hover) {
            dctx.strokeStyle = "rgba(255, 200, 210, 0.98)";
            dctx.lineWidth = 2;
            dctx.strokeRect(state.hover.i * cw + 0.5, state.hover.j * ch + 0.5, Math.max(1, cw - 1), Math.max(1, ch - 1));
          }
        }

        function getTopViewFrame() {
          const w = state.width;
          const h = state.height;
          const m = 26;
          const maxW = Math.max(20, w - m * 2);
          const maxH = Math.max(20, h - m * 2);

          const p = state.dxfProfile;
          const spanX =
            p && p.bounds ? Math.abs((p.bounds.x_max || 0) - (p.bounds.x_min || 0)) : GRID_W;
          const spanY =
            p && p.bounds ? Math.abs((p.bounds.y_max || 0) - (p.bounds.y_min || 0)) : GRID_H;
          const dwgAspect = spanY > 1e-9 ? spanX / spanY : GRID_W / GRID_H;
          const targetAspect = clamp(dwgAspect, 1.4, 4.0);

          let fw = maxW;
          let fh = fw / targetAspect;
          if (fh > maxH) {
            fh = maxH;
            fw = fh * targetAspect;
          }

          const fx = m + (maxW - fw) * 0.5;
          const fy = m + (maxH - fh) * 0.5;
          return { x: fx, y: fy, w: fw, h: fh, margin: m };
        }

        function drawTopView() {
          const w = state.width;
          const h = state.height;
          const frame = getTopViewFrame();
          const m = frame.margin;
          const iw = frame.w;
          const ih = frame.h;
          const ox = frame.x;
          const oy = frame.y;

          topCtx.clearRect(0, 0, w, h);
          const g = topCtx.createLinearGradient(0, 0, 0, h);
          g.addColorStop(0, "#05070b");
          g.addColorStop(1, "#020307");
          topCtx.fillStyle = g;
          topCtx.fillRect(0, 0, w, h);

          topCtx.strokeStyle = "rgba(36, 52, 74, 0.35)";
          topCtx.lineWidth = 1;
          topCtx.strokeRect(m + 0.5, m + 0.5, Math.max(1, w - m * 2 - 1), Math.max(1, h - m * 2 - 1));

          topCtx.strokeStyle = "rgba(84, 102, 129, 0.42)";
          topCtx.lineWidth = 1;
          topCtx.strokeRect(ox + 0.5, oy + 0.5, iw - 1, ih - 1);

          const cw = iw / GRID_W;
          const ch = ih / GRID_H;

          // Draw rods as white points on dark background, like DWG top view.
          topCtx.globalAlpha = 0.92;
          topCtx.fillStyle = "#f3f7ff";
          for (let i = 0; i < state.rods.count; i++) {
            const x = state.rods.x[i];
            const z = state.rods.z[i];
            const sx = ox + ((x + GRID_W * 0.5) / GRID_W) * iw;
            const sy = oy + ((z + GRID_H * 0.5) / GRID_H) * ih;
            if (sx < ox || sx > ox + iw || sy < oy || sy > oy + ih) continue;
            topCtx.fillRect(sx, sy, 1, 1);
          }
          topCtx.globalAlpha = 1;

          if (state.hover) {
            topCtx.fillStyle = "rgba(227, 58, 85, 0.18)";
            topCtx.fillRect(
              ox + state.hover.i * cw + 0.5,
              oy + state.hover.j * ch + 0.5,
              Math.max(1, cw - 1),
              Math.max(1, ch - 1)
            );
            topCtx.strokeStyle = "rgba(215, 36, 66, 0.95)";
            topCtx.lineWidth = 2;
            topCtx.strokeRect(
              ox + state.hover.i * cw + 0.5,
              oy + state.hover.j * ch + 0.5,
              Math.max(1, cw - 1),
              Math.max(1, ch - 1)
            );
          }

          topCtx.fillStyle = "rgba(188, 205, 228, 0.9)";
          topCtx.font = "12px ui-sans-serif, system-ui, sans-serif";
          topCtx.fillText("DWG 2D план | точки нитей", m, h - 10);
        }

        function shadeHex(hex, factor) {
          const clean = hex.replace("#", "");
          const r = parseInt(clean.slice(0, 2), 16);
          const g = parseInt(clean.slice(2, 4), 16);
          const b = parseInt(clean.slice(4, 6), 16);
          const rr = clamp(Math.round(r * factor), 0, 255);
          const gg = clamp(Math.round(g * factor), 0, 255);
          const bb = clamp(Math.round(b * factor), 0, 255);
          return "rgb(" + rr + "," + gg + "," + bb + ")";
        }

        function drawSegment3D(a, b, color, width) {
          const p0 = projectPoint(a.x, a.y, a.z);
          const p1 = projectPoint(b.x, b.y, b.z);
          if (!p0 || !p1) return;
          const lineW = clamp(width * (260 / Math.max(30, (p0.cz + p1.cz) * 0.5)), 0.8, 4.6);
          ctx.strokeStyle = color;
          ctx.lineWidth = lineW;
          ctx.beginPath();
          ctx.moveTo(p0.sx, p0.sy);
          ctx.lineTo(p1.sx, p1.sy);
          ctx.stroke();
        }

        function drawCuboid(center, size, baseColor, edgeColor) {
          const hx = size.x * 0.5;
          const hy = size.y * 0.5;
          const hz = size.z * 0.5;
          const verts = [
            { x: center.x - hx, y: center.y - hy, z: center.z - hz },
            { x: center.x + hx, y: center.y - hy, z: center.z - hz },
            { x: center.x - hx, y: center.y + hy, z: center.z - hz },
            { x: center.x + hx, y: center.y + hy, z: center.z - hz },
            { x: center.x - hx, y: center.y - hy, z: center.z + hz },
            { x: center.x + hx, y: center.y - hy, z: center.z + hz },
            { x: center.x - hx, y: center.y + hy, z: center.z + hz },
            { x: center.x + hx, y: center.y + hy, z: center.z + hz }
          ];

          const projected = new Array(8);
          for (let i = 0; i < 8; i++) {
            projected[i] = projectPoint(verts[i].x, verts[i].y, verts[i].z);
            if (!projected[i]) return;
          }

          const faces = [
            { ids: [0, 4, 6, 2], n: { x: -1, y: 0, z: 0 } },
            { ids: [1, 3, 7, 5], n: { x: 1, y: 0, z: 0 } },
            { ids: [0, 1, 5, 4], n: { x: 0, y: -1, z: 0 } },
            { ids: [2, 6, 7, 3], n: { x: 0, y: 1, z: 0 } },
            { ids: [0, 2, 3, 1], n: { x: 0, y: 0, z: -1 } },
            { ids: [4, 5, 7, 6], n: { x: 0, y: 0, z: 1 } }
          ];

          const visibleFaces = [];
          for (let i = 0; i < faces.length; i++) {
            const face = faces[i];
            const avg = {
              x: (verts[face.ids[0]].x + verts[face.ids[1]].x + verts[face.ids[2]].x + verts[face.ids[3]].x) * 0.25,
              y: (verts[face.ids[0]].y + verts[face.ids[1]].y + verts[face.ids[2]].y + verts[face.ids[3]].y) * 0.25,
              z: (verts[face.ids[0]].z + verts[face.ids[1]].z + verts[face.ids[2]].z + verts[face.ids[3]].z) * 0.25
            };
            const toCam = {
              x: state.camPos.x - avg.x,
              y: state.camPos.y - avg.y,
              z: state.camPos.z - avg.z
            };
            const facing = face.n.x * toCam.x + face.n.y * toCam.y + face.n.z * toCam.z;
            if (facing <= 0) continue;

            const depth =
              (projected[face.ids[0]].cz +
                projected[face.ids[1]].cz +
                projected[face.ids[2]].cz +
                projected[face.ids[3]].cz) *
              0.25;
            visibleFaces.push({ face, depth });
          }

          visibleFaces.sort((a, b) => b.depth - a.depth);
          for (let i = 0; i < visibleFaces.length; i++) {
            const face = visibleFaces[i].face;
            let shade = 0.78;
            if (face.n.y > 0.5) shade = 1.05;
            else if (face.n.y < -0.5) shade = 0.52;
            else if (Math.abs(face.n.x) > 0.5) shade = 0.72;
            else if (Math.abs(face.n.z) > 0.5) shade = 0.84;

            ctx.fillStyle = shadeHex(baseColor, shade);
            ctx.beginPath();
            ctx.moveTo(projected[face.ids[0]].sx, projected[face.ids[0]].sy);
            ctx.lineTo(projected[face.ids[1]].sx, projected[face.ids[1]].sy);
            ctx.lineTo(projected[face.ids[2]].sx, projected[face.ids[2]].sy);
            ctx.lineTo(projected[face.ids[3]].sx, projected[face.ids[3]].sy);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = edgeColor;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }

        function drawSubsystemPanels(panelY, spanX, spanZ) {
          const panelW = 8.8;
          const panelD = 5.6;
          const gap = 0.55;
          const cols = 6;
          const rows = 4;
          const startX = -((cols * panelW + (cols - 1) * gap) * 0.5) + panelW * 0.5;
          const startZ = -((rows * panelD + (rows - 1) * gap) * 0.5) + panelD * 0.5;
          const anchors = [];

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const cx = startX + c * (panelW + gap);
              const cz = startZ + r * (panelD + gap);
              if (Math.abs(cx) > spanX * 0.62 || Math.abs(cz) > spanZ * 0.62) {
                continue;
              }

              drawCuboid(
                { x: cx, y: panelY, z: cz },
                { x: panelW, y: 0.35, z: panelD },
                "#cfd5dc",
                "rgba(64,72,86,0.8)"
              );

              // Perforation on every panel
              for (let iy = 0; iy < 4; iy++) {
                for (let ix = 0; ix < 8; ix++) {
                  const shift = (iy % 2) * (panelW * 0.02);
                  const hx = cx - panelW * 0.35 + ix * (panelW * 0.10) + shift;
                  const hz = cz - panelD * 0.31 + iy * (panelD * 0.21);
                  const hp = projectPoint(hx, panelY + 0.2, hz);
                  if (!hp) continue;
                  const rr = clamp(3.0 * (170 / hp.cz), 0.55, 2.1);
                  ctx.beginPath();
                  ctx.arc(hp.sx, hp.sy, rr, 0, Math.PI * 2);
                  ctx.fillStyle = "rgba(66,73,88,0.88)";
                  ctx.fill();
                }
              }

              anchors.push({ x: cx, z: cz, y: panelY + 0.25 });
            }
          }

          return anchors;
        }

        function drawSubsystemModel() {
          updateCameraBasis();

          const gradient = ctx.createLinearGradient(0, 0, 0, state.height);
          gradient.addColorStop(0, "#060a12");
          gradient.addColorStop(1, "#03050a");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, state.width, state.height);

          const topY = 11.2;
          const midY = 2.9;
          const panelY = -6.2;
          const spanX = 56;
          const spanZ = 32;

          // Level III: ceiling panels
          const panelAnchors = drawSubsystemPanels(panelY, spanX, spanZ);

          // Level II: adaptive subsystem (blue rails)
          const xRails = [-22, -11, 0, 11, 22];
          const zRails = [-13, -4.3, 4.3, 13];
          for (let i = 0; i < xRails.length; i++) {
            drawCuboid(
              { x: xRails[i], y: midY, z: 0 },
              { x: 1.2, y: 0.7, z: spanZ * 0.88 },
              "#3b6fb8",
              "rgba(139,169,221,0.75)"
            );
          }
          for (let i = 0; i < zRails.length; i++) {
            drawCuboid(
              { x: 0, y: midY, z: zRails[i] },
              { x: spanX * 0.84, y: 0.7, z: 1.2 },
              "#3b6fb8",
              "rgba(139,169,221,0.75)"
            );
          }

          // Service path and inner lattice
          drawCuboid(
            { x: 0, y: midY + 0.35, z: 0.3 },
            { x: 20, y: 0.42, z: 4.2 },
            "#a7adb4",
            "rgba(227,236,245,0.65)"
          );
          for (let i = -9; i <= 9; i += 2) {
            drawSegment3D(
              { x: i, y: midY + 1.8, z: -1.3 },
              { x: i, y: midY + 1.8, z: 1.9 },
              "rgba(208,216,226,0.7)",
              0.9
            );
          }
          drawSegment3D({ x: -10, y: midY + 2.3, z: -1.9 }, { x: 10, y: midY + 2.3, z: -1.9 }, "rgba(210,220,230,0.72)", 1);
          drawSegment3D({ x: -10, y: midY + 2.3, z: 2.5 }, { x: 10, y: midY + 2.3, z: 2.5 }, "rgba(210,220,230,0.72)", 1);

          // Connectors between adaptive subsystem and panels
          for (let i = 0; i < panelAnchors.length; i++) {
            const a = panelAnchors[i];
            let nx = xRails[0];
            let nz = zRails[0];
            let bestDx = Math.abs(a.x - nx);
            let bestDz = Math.abs(a.z - nz);

            for (let xi = 1; xi < xRails.length; xi++) {
              const d = Math.abs(a.x - xRails[xi]);
              if (d < bestDx) {
                bestDx = d;
                nx = xRails[xi];
              }
            }
            for (let zi = 1; zi < zRails.length; zi++) {
              const d = Math.abs(a.z - zRails[zi]);
              if (d < bestDz) {
                bestDz = d;
                nz = zRails[zi];
              }
            }

            const topConn = { x: nx, y: midY - 0.45, z: nz };
            const botConn = { x: a.x, y: a.y, z: a.z };

            drawSegment3D(topConn, botConn, "rgba(255, 66, 47, 0.95)", 1.25);
            drawCuboid(
              { x: topConn.x, y: topConn.y - 0.05, z: topConn.z },
              { x: 0.82, y: 0.18, z: 0.82 },
              "#d8dee7",
              "rgba(245,248,252,0.7)"
            );
            drawCuboid(
              { x: botConn.x, y: botConn.y + 0.05, z: botConn.z },
              { x: 0.72, y: 0.12, z: 0.72 },
              "#d8dee7",
              "rgba(245,248,252,0.7)"
            );
          }

          // Vertical hangers
          const hangerXs = [-23, -11, 0, 11, 23];
          const hangerZs = [-12, 0, 12];
          for (let xi = 0; xi < hangerXs.length; xi++) {
            for (let zi = 0; zi < hangerZs.length; zi++) {
              const x = hangerXs[xi];
              const z = hangerZs[zi];
              drawSegment3D(
                { x, y: topY - 1.0, z },
                { x, y: midY + 0.4, z },
                "rgba(196,204,214,0.92)",
                1.2
              );
              drawCuboid(
                { x, y: midY + 0.05, z },
                { x: 0.95, y: 0.3, z: 0.95 },
                "#8393a8",
                "rgba(195,208,224,0.55)"
              );
            }
          }

          // Level I: primary red supporting frame
          const topXBars = [-14, -5, 5, 14];
          const topZBars = [-9.5, 0, 9.5];
          drawCuboid(
            { x: 0, y: topY, z: -spanZ * 0.5 + 1.1 },
            { x: spanX, y: 1.9, z: 2.2 },
            "#c34a45",
            "rgba(255,211,211,0.6)"
          );
          drawCuboid(
            { x: 0, y: topY, z: spanZ * 0.5 - 1.1 },
            { x: spanX, y: 1.9, z: 2.2 },
            "#c34a45",
            "rgba(255,211,211,0.6)"
          );
          drawCuboid(
            { x: -spanX * 0.5 + 1.1, y: topY, z: 0 },
            { x: 2.2, y: 1.9, z: spanZ - 4.2 },
            "#c34a45",
            "rgba(255,211,211,0.6)"
          );
          drawCuboid(
            { x: spanX * 0.5 - 1.1, y: topY, z: 0 },
            { x: 2.2, y: 1.9, z: spanZ - 4.2 },
            "#c34a45",
            "rgba(255,211,211,0.6)"
          );

          for (let i = 0; i < topZBars.length; i++) {
            drawCuboid(
              { x: 0, y: topY, z: topZBars[i] },
              { x: spanX - 6.2, y: 1.5, z: 1.55 },
              "#bf433f",
              "rgba(255,196,196,0.55)"
            );
          }
          for (let i = 0; i < topXBars.length; i++) {
            drawCuboid(
              { x: topXBars[i], y: topY, z: 0 },
              { x: 1.55, y: 1.5, z: spanZ - 6.4 },
              "#bf433f",
              "rgba(255,196,196,0.55)"
            );
          }

          // Small legend in subsystem tab
          ctx.fillStyle = "rgba(220,230,245,0.95)";
          ctx.font = "700 13px ui-sans-serif, system-ui, sans-serif";
          ctx.fillText("Подсистема: Уровень I (каркас) / Уровень II (адаптивная сетка) / Уровень III (панели)", 16, state.height - 16);
        }

        function setActiveTab(tab) {
          state.activeTab = tab;
          const isTop = tab === "2d";
          viewport.style.display = isTop ? "none" : "block";
          topViewport.style.display = isTop ? "block" : "none";
          viewerArrows.classList.toggle("hidden", isTop);
          tab3dBtn.classList.toggle("active", tab === "3d");
          tab2dBtn.classList.toggle("active", tab === "2d");
          state.hover = null;
          tooltip.style.display = "none";
          state.needsRender = true;
        }

        function render() {
          if (state.activeTab === "3d") {
            updateCameraBasis();

            const gradient = ctx.createLinearGradient(0, 0, 0, state.height);
            gradient.addColorStop(0, "#060a12");
            gradient.addColorStop(1, "#03050a");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, state.width, state.height);

            drawFloorFrame();
            drawRods();
            drawHoveredPanel();
          } else {
            drawTopView();
          }

          drawDensityMap();

          state.needsRender = false;
        }

        function updateHoverTop(mouseX, mouseY) {
          const frame = getTopViewFrame();
          const iw = frame.w;
          const ih = frame.h;
          const ox = frame.x;
          const oy = frame.y;
          if (mouseX < ox || mouseX > ox + iw || mouseY < oy || mouseY > oy + ih) {
            state.hover = null;
            tooltip.style.display = "none";
            state.needsRender = true;
            return;
          }

          const i = Math.floor(((mouseX - ox) / iw) * GRID_W);
          const j = Math.floor(((mouseY - oy) / ih) * GRID_H);
          if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) {
            state.hover = null;
            tooltip.style.display = "none";
            state.needsRender = true;
            return;
          }

          const density = state.panelDensity[j * GRID_W + i];
          const lengthN = state.panelLength[j * GRID_W + i];
          if (density < 0) {
            state.hover = null;
            tooltip.style.display = "none";
            state.needsRender = true;
            return;
          }

          state.hover = { i, j, density, lengthN };
          tooltip.style.display = "block";
          tooltip.style.left = Math.min(Math.max(12, mouseX + 10), state.width - 205) + "px";
          tooltip.style.top = Math.min(Math.max(46, mouseY + 6), state.height - 10) + "px";
          const worldX = (i - GRID_W * 0.5 + 0.5).toFixed(1);
          const worldY = (j - GRID_H * 0.5 + 0.5).toFixed(1);
          const lengthEst = lerp(state.minLength, state.maxLength, clamp(lengthN, 0, 1)).toFixed(2);
          tooltip.innerHTML =
            '<div style="color:#7fd3ff;font-weight:700;margin-bottom:3px">Панель 1x1 м</div>' +
            "Координаты: X " +
            worldX +
            "м, Y " +
            worldY +
            "м<br>Нитей в квадрате 1x1м: " +
            density +
            " шт<br>Средняя длина в зоне: " +
            lengthEst +
            " м";

          state.needsRender = true;
        }

        function updateHover(mouseX, mouseY) {
          const hit = screenRayToGround(mouseX, mouseY);
          if (!hit) {
            state.hover = null;
            tooltip.style.display = "none";
            state.needsRender = true;
            return;
          }

          const i = Math.floor(hit.x + GRID_W * 0.5);
          const j = Math.floor(hit.z + GRID_H * 0.5);
          if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) {
            state.hover = null;
            tooltip.style.display = "none";
            state.needsRender = true;
            return;
          }

          const density = state.panelDensity[j * GRID_W + i];
          const lengthN = state.panelLength[j * GRID_W + i];
          if (density < 0) {
            state.hover = null;
            tooltip.style.display = "none";
            state.needsRender = true;
            return;
          }

          state.hover = { i, j, density, lengthN };
          tooltip.style.display = "block";
          tooltip.style.left = Math.min(Math.max(12, mouseX + 10), state.width - 205) + "px";
          tooltip.style.top = Math.min(Math.max(46, mouseY + 6), state.height - 10) + "px";
          const worldX = (i - GRID_W * 0.5 + 0.5).toFixed(1);
          const worldY = (j - GRID_H * 0.5 + 0.5).toFixed(1);
          const lengthEst = lerp(state.minLength, state.maxLength, clamp(lengthN, 0, 1)).toFixed(2);
          tooltip.innerHTML =
            '<div style="color:#7fd3ff;font-weight:700;margin-bottom:3px">Панель 1x1 м</div>' +
            "Координаты: X " +
            worldX +
            "м, Y " +
            worldY +
            "м<br>Нитей в квадрате 1x1м: " +
            density +
            " шт<br>Средняя длина в зоне: " +
            lengthEst +
            " м";

          state.needsRender = true;
        }

        function resize() {
          state.dpr = Math.min(window.devicePixelRatio || 1, 2);
          state.width = Math.max(1, viewport.clientWidth);
          state.height = Math.max(1, viewport.clientHeight);

          viewport.width = Math.floor(state.width * state.dpr);
          viewport.height = Math.floor(state.height * state.dpr);
          topViewport.width = Math.floor(state.width * state.dpr);
          topViewport.height = Math.floor(state.height * state.dpr);
          ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
          topCtx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);

          state.focal = (state.height * 0.5) / Math.tan(state.fov * 0.5);
          state.needsRender = true;
        }

        function scheduleRebuild() {
          if (state.pendingRebuild) {
            clearTimeout(state.pendingRebuild);
          }
          state.pendingRebuild = setTimeout(() => {
            state.pendingRebuild = null;
            rebuildSimulation();
          }, 80);
        }

        function initReferencePattern() {
          const dwgLoaded = !!state.dxfProfile;
          patternSourceValue.textContent = dwgLoaded
            ? "DWG профиль загружен"
            : "DWG профиль не найден";
          statusEl.textContent = dwgLoaded ? "DWG профиль загружен" : "DWG профиль не найден";
          state.referenceMap = null;
          rebuildSimulation();
        }

        viewport.addEventListener("contextmenu", (e) => e.preventDefault());
        topViewport.addEventListener("contextmenu", (e) => e.preventDefault());

        tab3dBtn.addEventListener("click", () => setActiveTab("3d"));
        tab2dBtn.addEventListener("click", () => setActiveTab("2d"));

        function bindArrowButton(btn, yawDelta, pitchDelta) {
          let timer = null;
          const step = () => {
            if (state.activeTab !== "3d") return;
            state.yaw += yawDelta;
            state.pitch = clamp(state.pitch + pitchDelta, 0.14, 1.2);
            state.needsRender = true;
          };
          const start = (e) => {
            e.preventDefault();
            step();
            if (timer) clearInterval(timer);
            timer = setInterval(step, 55);
          };
          const stop = () => {
            if (!timer) return;
            clearInterval(timer);
            timer = null;
          };

          btn.addEventListener("pointerdown", start);
          btn.addEventListener("pointerup", stop);
          btn.addEventListener("pointerleave", stop);
          btn.addEventListener("pointercancel", stop);
          window.addEventListener("mouseup", stop);
          window.addEventListener("blur", stop);
        }

        bindArrowButton(rotLeftBtn, 0.06, 0);
        bindArrowButton(rotRightBtn, -0.06, 0);
        bindArrowButton(rotUpBtn, 0, -0.045);
        bindArrowButton(rotDownBtn, 0, 0.045);

        viewport.addEventListener("mousedown", (e) => {
          if (state.activeTab !== "3d") return;
          state.dragging = true;
          state.dragButton = e.button;
          state.lastMouseX = e.clientX;
          state.lastMouseY = e.clientY;
          viewport.classList.add("grabbing");
        });

        window.addEventListener("mouseup", () => {
          state.dragging = false;
          viewport.classList.remove("grabbing");
        });

        window.addEventListener("mousemove", (e) => {
          if (state.activeTab !== "3d") return;
          const rect = viewport.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left &&
            e.clientX <= rect.right &&
            e.clientY >= rect.top &&
            e.clientY <= rect.bottom;

          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;

          state.mouse.x = mx;
          state.mouse.y = my;

          if (!inside && !state.dragging) return;

          if (state.dragging) {
            const dx = e.clientX - state.lastMouseX;
            const dy = e.clientY - state.lastMouseY;
            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;

            if (state.dragButton === 0) {
              state.yaw -= dx * 0.006;
              state.pitch -= dy * 0.005;
              state.pitch = clamp(state.pitch, 0.14, 1.2);
            } else if (state.dragButton === 2) {
              updateCameraBasis();
              const panScale = 0.045 * (state.distance / 90);
              state.target.x -= state.basisRight.x * dx * panScale;
              state.target.z -= state.basisRight.z * dx * panScale;

              const flatForward = normalize({
                x: state.basisForward.x,
                y: 0,
                z: state.basisForward.z
              });
              state.target.x += flatForward.x * dy * panScale;
              state.target.z += flatForward.z * dy * panScale;
            }

            state.needsRender = true;
          }

          if (inside) {
            updateHover(mx, my);
          } else {
            state.hover = null;
            tooltip.style.display = "none";
            state.needsRender = true;
          }
        });

        topViewport.addEventListener("mousemove", (e) => {
          if (state.activeTab !== "2d") return;
          const rect = topViewport.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          state.mouse.x = mx;
          state.mouse.y = my;
          updateHoverTop(mx, my);
        });

        topViewport.addEventListener("mouseleave", () => {
          if (state.activeTab !== "2d") return;
          state.hover = null;
          tooltip.style.display = "none";
          state.needsRender = true;
        });

        viewport.addEventListener(
          "wheel",
          (e) => {
            if (state.activeTab !== "3d") return;
            e.preventDefault();
            const factor = e.deltaY > 0 ? 1.08 : 0.92;
            state.distance = clamp(state.distance * factor, 35, 180);
            state.needsRender = true;
            updateHover(state.mouse.x, state.mouse.y);
          },
          { passive: false }
        );

        totalThreadsInput.addEventListener("input", () => {
          const val = Number(totalThreadsInput.value);
          if (Number.isFinite(val) && val > 0) {
            totalThreadsValue.textContent = Math.round(val).toLocaleString("ru-RU") + " нитей";
          }
          scheduleRebuild();
        });

        totalThreadsInput.addEventListener("change", () => {
          scheduleRebuild();
        });

        totalThreadsInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            scheduleRebuild();
          }
        });

        window.addEventListener("resize", resize);

        function loop() {
          if (state.needsRender) {
            render();
          }
          requestAnimationFrame(loop);
        }

        try {
          resize();
          setActiveTab("3d");
          initReferencePattern();
          loop();
        } catch (err) {
          errorEl.style.display = "flex";
          errorEl.textContent = "Ошибка рендера: " + (err && err.message ? err.message : String(err));
          statusEl.textContent = "Ошибка";
        }
      })();
    </script>
  </body>
</html>
